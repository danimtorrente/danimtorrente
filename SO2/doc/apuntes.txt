<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<USO GENERAL DEL SO>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Llamadas a sistema:
	-Gestion de Procesos:
		-getpid
		-fork
		-exit
		-exec
	-Gestion de Memoria:
		-malloc
		-free
		-brk/sbrk
	-I/O & filesystem
		-open
		-read
		-write
		-close
		-lseek
		-mknod
	-Soporte para multithreads/multiprocess
		-pthreads_*
		-signal
		-kill
		-pipe
		-socket
		-sem_*
		-clone

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<ANOTACIONES DEL HARDWARE>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

- Controlador i2c, Inter-integrated Circuit, se usa para touchpad, pantallas tactiles, teclados...
- Los laptops usan para el keyboard normalmente el controlador i8042
- PCI--> Es un bus que se usa para interconectar varios dispositivos sobre todo en placas base para conectar componentes como 
	tarjetas graficas, de red, de sonido...

AQUITECTURA (X86)

	- Tss
	- Registros para sysenter/sysexit

	- CPU Registers:
                -ss (stack segment): apunta al segmento de la pila
                -esp (extended stack pointer): contiene la direccion actual del tope de la pila
                -psw (program status word o EFLAGS en x86): contiene flags que describen el estado actual 
							    del procesador(overflow, zero...)
                -cs (code segment): apunta al segmento de codigo en memoria, define donde esta el codigo que se ejecuta
                -eip (extended instruction pointer): contiene la direccion de la proxima instruccion que sera ejecutada en la 
			CPU
		((¡¡¡Revisar!!!)-__Kernel_ds) -> kernel data segment
	- General Purpose Registers:
                -EAX, EBX, ECX, EDX --> Proposito general, aunque cada uno se suele usar para una cosa diferente. En EAX se pone
					el valor del resultado de una subrutina o interrupcion, 
		-ESI-> Para manipulacion de datos en memoria. Apunta al origen de los datos en memoria
		-EDI-> Para manipulacion de datos en memoria. Apunta el destino de los datos en memoria
		-EBP-> Gestion de pila. Contiene la direccion base de la pila
		-ESP-> Gestion de pila. Contiene la direccion tope de la pila

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<CONFIGURACION DEL SO INICIAL>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

LINKERS (por ejemplo ld)

-El linker combina varios archivos objeto (archivos ya compilados en binario) en un ejecutable, resuelve simbolos y 
 ajusta las direcciones de memoria, es lo que se llama montaje. Por ejemplo el archivo binario puede tener funciones que hagan 
 referencia a bibliotecas externas, una de las cosas que el linker haria seria coger el trozo de codigo que se usa y integrarlo 
 en el archivo ejecutable resultante

ARCHIVO LDS

-Un archivo lds define la ubicacion de las secciones del kernel en la memoria y controla detalles criticos sobre 
 como se organiza el codigo y los datos. Aqui esta un ejemplo: 

ENTRY(main)
SECTIONS
{
	. = 0x10000; /* system code begins here */
	.text.main :
		{ BYTE(24); /* reserved to store user code management data */
			*(.text.main) }
	.text : {*(.text) }
	.rodata : { *(.rodata) }
	.data : { *(.data) } /* Initialized data */
	.bss : { *(.bss) } /* Not initialized data */
	. = ALIGN(4096); /* task_structs array aligned to page */
	.data.task : { *(.data.task) }
}

EXPLICACION:

ENTRY--> Le dice al linker que el punto de entrada sera la funcion main
SECTIONS--> Dentro de sections defines como quieres que se coloquen diferentes partes del programa en memoria.
	-0x10000 (64kB)--> Indica que el codigo del programa comienza en esta direccion
	-text.main --> subseccion de texto (donde se almacena el codigo) en la que se almacena la funcion main
	-BYTE(24) --> reserva 24 bytes para almacenar datos relacionados con la gestion de codigo de usuario (puede ser usado 
		por el sistema operativo para guardar datos de control como punteros o descriptores)
	-*(.text.main) --> Instruye al linker para colocar en esta sección cualquier código que esté en la sección .text.main 
		de los archivos objeto.
	-.text --> Seccion de codigo ejecutable del programa
	-.rodata--> Read Only Data
	-.data--> Datos inicializados como variables globales que ya tienen un valor o datos asi
	-.bss--> Datos no inicializados
	-. = ALIGN(4096)--> Alinea al tamaño de una pagina de 4 KB
	-data.task--> Seccion para los datos relacionados con tareas (procesos o threads)


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<BOOTSTRAP --> proceso de INICIALIZACION DEL DISPOSITIVO>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Power-on da energia al dispositivo pero este no tiene nada configurado. Se pone el pin RESET del procesador a 1 mediante un 
ciruito hardware, esto carga algunos valores hardcodeados a los registros y se ejecuta el codigo BIOS (Basic Input Output 
System) de una direccion de memoria concreta almacenada en una ROM (Read Only Memory). Todo desde el inicio hasta que empiece a 
cargarse el kernel se ejecuta en real mode (direcciones fisicas de memoria).

Estructura BIOS o UEFI (Unified Extensible Firmware Interface):
1) POST (Power-on self test) --> Comprueba que todo el hardware este conectado y funcione correctamente.
2) Inicializa todos los dispositivos hardware y crea una tabla de dispositivos hardware conectados mediante PCI (Peripheral 
	Component Interconect)
3) Busca un sistema operativo para cargarlo
4) Cuando lo encuentra copia el contenido del primer sector a la RAM (este contenido sera el bootloader, que es el programa 
	para cargar el OS) y lo empieza a ejecutar

BOOTLOADER --> Es el primer programa del sistema operativo que se ejecuta (<<<CONSULTAR THE LINUX KERNEL, APENDIX A>>>).
Hace lo siguiente: 
- 
- 
-
-
-
-
-

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<MANEJO DE INTERRUPCIONES>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

1) Salta una interrupcion, el procesador consulta la IDT para determinar la direccion del handler correspondiente
2) Cambio de contexo (el procesador guarda el estado actual del sistema (flags, registros...) en la pila y cambia al modo de 
	ejecucion del nivel de privilegio correspondiente). Es decir que guarda registros del contexto hardware y software 
	del modo usuario en la pila del modo kernel
3) El procesador usa la GDT para conseguir el codigo y datos necesarios, se ejecuta el HANDLER
4) Se restaura al contexto anterior y su nivel de privilegios y finalmente el procesador usa IRET (interrupt return), que 
	indica que hay que volver a ejecutar la siguiente instruccion original (antes de la interrupcion).

Interrupts--> Asynchronous, producido por otros dispositivos hardware de forma inesperada

Exceptions--> Synchronous, interrupciones generadas por la CPU despues de terminar una instruccion

Systemcalls--> Synchronous, lo causa una instruccion de assembler. Es una llamada al kernel des de un programa de usuario para 
	       ejecutar una intruccion de sistema que solo puede ejecutar el kernel. En los pc mas antiguos se usa int, en los
	       mas modernos se usa sysenter.

	-int --> Abreviatura de interrupt, se usa int + entrada IDT. Por lo general para system calls es int 0x80. 
		En los diferentes registros se guardan valores necesarios:
			-EAX-> Especifica el tipo de funcion del kernel que se hara (read, write...)
			-EBX-> Descriptor de archivo (0;stdin(teclado), 1;stdout(pantalla), 2;stderr(error))
			-ECX-> Direccion del mensaje (¿suele ser la etiqueta msg?)
			-EDX-> Longitud del mensaje

	-Sysenter/sysexit--> Mecanismo de gestion de interrupciones que se salta el vector de interrupciones (IDT).
		     Solo para systemcalls. Usa los siguientes registros:
			-SYSENTER_CS_MSR--> Selector de segmento de codigo del kernel
			-SYSENTER_EIP_MSR--> Contiene el entry point, la direccion de memoria donde comienza la ejecucion en el 
					     kernel cuando se invoca sysenter
			-SYSENTER_ESP_MSR--> Apunta a la base de la TSS (Task State Segment). Esta contiene informacion sobre el 
					     estado de una tarea o proceso, incluyendo el puntero de la pila (ESP) del kernel.
		     Cuando termina la ejecucion, se devuelve el control al usuario con la instruccion sysexit

IDT (Interrupt Descriptor table) --> Cada entrada tiene un puntero al handler, un nivel de privilegio minimo necesario
	-256 entradas: 
		-0-31 Excepciones (generadas por la cpu, cuando se divide entre cero o cosas asi)
		-32-47 Masked/hardware Interrupts (interrupciones hardware, se las llama masked porque si llegan en un momento 
			critico, se enmascaran/deshabilitan temporalmente hasta que se puedan tratar)
		-48-255 Software Interrupts o Traps: invocadas por software y no por hardware. Se usan para syscalls o 
			eventos definidos por el usuario o software

GDT (Global Descriptor table) --> Contiene descriptores de segmentos de codigo en memoria. Su direccion, tamaño, privilegios...

Handler--> Funcion que trata una interrupcion
	-Exception handler:
		-Save hardware context
		-Call exception service routine
		-Restore hardware context
		-Remove error code (if present) from kernel stack
		-Return to user (IRET)
	-Interrupt handler:
		-Save hardware context
		-End Of Interruption (EOI)
		-Call interrupt service routine (ISR)
		-Restore hardware context
		-IRET
	-System call handler (type of software interrupt)
		-Save hardware context and prepare parameters
		-Execute system call service routine
		-Update kernel context with the system call result
		-Restore hardware context
		-IRET

Wrapper--> Funcion que sirve de intermediario para simplificar una operacion compleja, como una llamada al sistema operativo
	Ejemplo de wrapper para la llamada a sistema write en lenguaje C: 
		-ssize_t write(int fd, const void *buf, size_t count);

Internamente, este wrapper en C invocará la llamada al sistema de bajo nivel que podría usar int 0x80 o sysenter/syscall

sysenter/sysexit:
Se usa para cargar esp guardador en el campo esp0 de la tss entre otros.
3 registros de control imprescindibles inicializados en tiempo de boot:
	– SYSENTER_CS_MSR: contains kernel cs selector
	– SYSENTER_EIP_MSR: contains kernel entry point
	– SYSENTER_ESP_MSR: points to the TSS base @

Pilas --> Cada proceso tiene 2 pilas, una de usuario y otra de kernel. La de usuario esta en el espacio de memoria de usuario, y 
	la del kernel esta en el espacio de direcciones del kernel, separada de la de usuario.

WINDOWS:

Para windows la gestion es un poco diferente. La direccion de idt para las sistemcalls con int es 0x2e, y en vez de pasar todos
los parametros en los registros, solo pasa un puntero con la direccion de memoria donde estaran todos los parametros.


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<PROCESOS>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ESPACIO DE DIRECCIONES DE UN PROCESO:

- Espacio de direcciones logicas del procesador: Rango de direcciones que puede acceder un procesador. Esta limitado 
		por el tamaño del bus de @. Es decir, si tienes 32 bits, como mucho tienes 2 a la 32 posiciones, es decir 4GB.

Por proceso:

- Espacio de direcciones logicas del proceso: 
	Las direcciones que usa un procesador cuando quiere acceder a datos/codigo/pila del proceso. Son relativas a
	una direccion 0, igual para todos los procesos. Es decir, que cada proceso tendra una direccion 0, pero luego 
	esta luego se tendra que traducir a una direccion de memoria fisica.
	Cada proceso tiene las siguientes regiones de datos:
		- Codigo (text) --> Instrucciones ejecutables
		- Datos inicializados (data) --> Variables globales y estaticas con valor inicial
		- Dataos no inicializados (bss) --> Variables globales y estaticas que no tienen un valor inicial
		- Heap (memoria dinámica)
		- Pila (usuario y kernel)

- Espacio de direcciones fisicas del proceso: Corresponde a las direcciones físicas de la memoria principal (RAM) asociadas 
	a direcciones logicas del proceso.

Traducción entre logicas (memoria virtual) y físicas:

La memoria virtual no es mas que todas las tecnicas que se comentan a continuacion para la gestion de memoria de cada proceso.
Es decir, que cuando hablamos de area de memoria virtual estamos hablando de un conjunto de direcciones logicas concreto.

Hoy en dia se usa un modelo plano sin segmentación significativa + paginacion multinivel (4 o 5 niveles en funcion de la 
arquitectura). En hardware x86 de 32 bits si se usa segmentacion paginada, es decir una direccion de memoria junto con un 
tamaño (segmento) que esta subdividido en paginas. La segmentacion que se usa en los modelos de hoy en dia, se llama 
segmentacion plana, y solo se usa para cosas mas especificas. Un ejemplo son los registros FS y GS que apuntan al segmento
que contiene la estructura de datos del thread.

- MMU (Memory Management Unit): estructura hardware que se encarga de traducir de @logicas a @fisicas. Depende del procesador
	este componente varia, pero por lo general su componente principal es el TLB.
		- TLB (Translation Lookaside Buffer): Memoria asociativa (cache) de acceso mas rápido en la que se 
			almacenan algunas entradas de la tabla de paginas que son visitadas con mayor frecuencia.
			Cada vez que se cambia la MMU hay que actualizar/invalidar (flush) el tlb.

- Segmentacion paginada: CPU --> UNIDAD SEGMENTACION --> UNIDAD PAGINACION --> MEMORIA FISICA
	- Segmentacion: Espacio logico del proceso dividido en segmentos, que a su vez estan divididos en paginas. 
		Tamaño de segmento es múltiplo del tamaño de pagina (porque el segmento esta subdividido en paginas). 
		· Tabla de segmentos: Una tabla por proceso. Contiene @base y tamaño de cada segmento.
		
	- Paginacion: La unidad de trabajo del sistema operativo.
		· Tabla de paginas: Una tabla por proceso. Contiene informacion a nivel de pagina como validez, 
			permisos de acceso, marco asociado...
			Hay de varios tipos:
				- Con un solo nivel: cada direccion es una entrada a la tabla de paginas y ya.
				- Con multiples niveles (en nuestro caso 2): Hay un directorio, que basicamente
					contiene direcciones de varias tablas de paginas. El flujo de datos seria
					CR3 (direccion page directory) >> PAGE DIRECTORY >> PAGE TABLE >> PAGE

	- Swap: 
		Swap es una técnica que permite utilizar parte del disco (swap space o archivo de intercambio) como extensión 
		de la memoria principal. Cuando no hay suficiente espacio en RAM para todas las páginas activas de un proceso, 
		el sistema operativo puede copiar algunas páginas de RAM a la región de swap en disco, liberando espacio físico.
		Al volver a necesitar esas páginas, se produce un page fault y se traen de vuelta a la RAM.
		La razon por la que se usa esto es que hay muchas paginas de un proceso que no estan asociadas a ningun archivo
		del disco como la pila, el heap o datos no inicializados, es por eso que es necesario.


Gestion de memoria en ZeOS:
- El SO debe conocer la @base de la tabla de paginas de cada proceso, en ZeOS se guarda en el PCB.
- En el registor cr3 se guarda ...
- No tiene un programa para cargar ejecutables en el SO, el codigo de usuario se carga en tiempo de boot.
- Flujo de accesos a memoria en ZeOS: CR3 >> DIRECTORY >> TABLA
- Espacio logico de direcciones: 
  USER MODE: 
	L_USER_START
		<<USER CODE>>
	DATA_START=L_USER_START+(NUM_PAG_CODE*PAGE_SIZE)
		<<USER DATA + STACK>>
	DATA_END=DATA_START+(NUM_PAG_DATA*PAGE_SIZE)

  KERNEL MODE: 

	KERNEL_START
		<<KERNEL CODE>>
		<<KERNEL DATA + STACKS>>
	L_USER_START
		<<USER CODE>>
	DATA_START=L_USER_START+(NUM_PAG_CODE*PAGE_SIZE)
		<<USER DATA + STACK>>
	DATA_END=DATA_START+(NUM_PAG_DATA*PAGE_SIZE)


- Espacio físico de direcciones: 
	<<KERNEL CODE>>
	<<KERNEL DATA + KERNEL STACKS>>
	<<USER CODE>>
	<<P0: USER DATA + STACKS>>
	<<P1: USER DATA + STACKS>>
	<<...>>

- Atributos por pagina: 
	typedef union
	{
		 unsigned int entry;
		 struct {
		 unsigned int present : 1; presente
		 unsigned int rw : 1; permisos
		 unsigned int user : 1; user/supervisor
		 unsigned int write_t : 1; write through/write_back (linux write back)
		 unsigned int cache_d : 1; caching is enable (linux sets this)
		 unsigned int accessed : 1; (reset by OS)
		 unsigned int dirty : 1; (set by OS)
		 unsigned int ps_pat : 1; (page_size: normal or big)
		 unsigned int global : 1; (if set, tlb is not flushed after modifying CR3)
		 unsigned int avail : 3; (not in use)
		 unsigned int pbase_addr : 20;
	 } bits;
	} page_table_entry;

PROCESOS:

Proceso: programa en ejecucion. Su definicion engloba todo lo necesario para que un programa se ejecute: ejecucion de secuencia 
	de instrucciones, estado actual, conjunto asociado de recursos...

El task_struct es la estructura que contiene toda la información sobre un proceso o tarea, como:
	-PID (Identificador del proceso)
	-Estado de la tarea (corriendo, detenido, en espera, etc.)
	-Recursos del proceso(paginas de memoria, ficheros abiertos...)
	-Punteros a los registros (para restaurar el contexto de la CPU cuando se programa la tarea)
	-Dirección de memoria (dónde está cargado el proceso en la memoria)
	-Contadores de tiempo (para la planificación por tiempos)
	-Informacion de planificacion (prioridad, quantum...)
	-...

El array task[] contiene todas las tareas o procesos en el sistema. Es como una lista que el sistema operativo usa para hacer un 
seguimiento de los procesos activos, programarlos, o eliminarlos.

union task_union task[NR_TASKS] __attribute__((__section__(".data.task"))); // MAS INFO EN EL ANEXO A

-union task_union--> Esto es una unión que contiene el pcb por arriba y el stack del proceso o pila por abajo. Es decir, 
 el task_struct esta en la direccion 0 del union y la pila en la sizeof(union).

	union task_union {
		struct task_struct task;
		unsigned long stack[1024];
	};

GESTION DE PROCESOS:
En la actualidad se combinan dos tecnicas para la creacion y destruccion de procesos. Una es tener la lista FREE con los
pcb disponibles y la otra es crear y destruir mediante memoria dinamica. Tambien se hace un hibrido de estos dos metodos.

Listas de procesos:
	READY: procesos esperando a ejecutarse cuando haya una cpu disponible
	BLOCKED: procesos bloqueados esperando a desbloquearse
	ZOMBIE: procesos zombie
	FREE: lista de pcb disponibles para un nuevo proceso


Identificacion de un proceso en ejecución: se le aplica una mascara al puntero a la pila esp, porque pila y pcb estan en la 
	misma pagina (union). Esto lo hace la macro current().

Cambio de contexto: Suspender la ejecución del proceso actual y continuar la ejecución de otro proceso “previamente” 
	suspendido. Pasos:
		– Guardar contexto ejecución proceso actual
			• Hay que guardar el contexto hw y como acceder a él: Se guarda el contexto hw en la pila de kernel,
				y en el pcb la posicion en la pila para acceder a el
		– Restaurar contexto ejecución proceso suspendido
			• Espacio de direcciones: actualizar estructuras mmu
			• TSS: esp0 tiene que apuntar a la base de la pila de sistema del proceso nuevo
			• Contexto hardware: restaurar mediante el esp que se guardo en el pcb previamente
			• Cargar en el PC la direccion del codigo a ejecutar

	De esto se encarga:
	- task_switch(union task_union * t): funcion en assembler 
		- Salvar ebp, esi, edi, ebx
		- Push del parámetro a la pila (push 8(%ebp))
		- call inner_task_switch
		- Eliminar parámetro de la pila (addl $4, %esp)
		- Restarurar registros popl ebx, edi, esi , ebp
		- ret

	- inner_task_switch(union task_union * t): funcion en C
		- tss.esp0 = kernel_esp(t);
		- writeMSR(0x175, tss.esp0, 0); // actualiza el registro 0x175 para que sysenter use la pila que toca al 
			entrar en modo kernel y asi no tener que entrar a la tss
		- set_cr3(get_Dir((struct task_struct) * t));
		- current->kernel.esp = (unsigned long *) get_ebp();
		- set_esp(t->task.kernel_esp);

Creacion de procesos:

El tipo de creacion de procesos que se explica es para UNIX, existen alternativas, pero para este curso solo hace falta UNIX.
	- Buscar PCB libre
	- Inicializar PCB
		- Asignar PID
		- Replicar estructuras y campos del proceso padre
			- Tabla de canales (por proceso)
			- Ficheros abiertos: Esta tabla no es por proceso, pero ahora los ficheros que se usaban en el 
				proceso 1, tambien se usaran en el nuevo, asi que en vez de tener un uno en el campo cantidad 
				de procesos que la usan, tendra un 2. Y cada entrada de la tabla ficheros abiertos apuntará al 
				inodo correspondiente, es decir, que la tabla de inodos no cambia.
	- Inicializar espacio de direcciones. Dos metodos:
		- Copia de toda la memoria del proceso padre: Implica reservar memoria física : fork
		- Compartición del espacio de direcciones con el proceso padre: Comparticion del espacio de direcciones
			con el proceso padre: threads (clone en linux)
	- Encolar PCB

fork: crea una copia del proceso que lo llama
	• Obtener PCB libre (lista FREE)
	• Asignar un nuevo PID
	• Heredar los datos de sistema (PCB i pila)
	• Asignar un nuevo espacio de @: directorio
	• Heredar los datos de usuario
	• Actualizar task_union hijo
	• Insertar proceso en la lista de procesos READY
	• Devolver el pid del nuevo proceso creado (0 al hijo)

Ejemplo de codigo de fork:


Creacion de procesos iniciales:
	Init--> Primer proceso de usuario
		- Coger task_union de la freequeue y luego eliminarlo
		- init->task.PID = 1
		- allocate_DIR(&init->task);
		- set_user_pages(&init->task);
		- task.quantum = default_quantum
		- quantum_left = task.quantum
		- init->task.kernel_esp = &(init->stack[size]);
		- Actualizar tss y writeMSR(0x175, tss.esp0)
		- set_cr3(init->task.dir_pages_baseAddr)
	
	Idle --> Proceso que solo ocupa cpu cunado no hay ningun otro candidato
		- Coger task_union de la freequeue y luego eliminarlo
		- idle->task.PID = 0
		- allocate_DIR(&idle->task);
		- Como la pila esta vacia añadir 2 elementos:
			- stack[size-2] = 0;
			- stack[size-1] = cpu_idle;
		- idle->task.kernel_esp = &(idle->stack[size-2]);
		- idle_task (variable global) = task
 
clone: lo mismo que fork pero para threads
-----------------------------------

Ejemplo de codigo de clone:
-----------------------------------

Destruccion de procesos:

	exit: llamada a sistema para destruir el proceso que la llama
		- Hay que liberar todos los recursos asignados:
			- liberar espacio de direcciones
			- liberar pcb: UNIX/LINUX pueden retrasar la liberacion del PCB
			- Todo lo que sea necesario: Entrada/Salida, semaforos...
		- Borrar proceso de la lista de procesos en ejecucion
		- Ejecutar planificacion: seleccionar nuevo proceso y restaurar su ejecucion
		UNIX: 
			- Proceso padre se puede sincronizar con el fin de sus hijos (waitpid)
				- Recoge cause muerte hijo (si exit o si signal)
				- Parametro del exit
			- Se guarda esta información en el PCB del hijo: Hasta que el padre no hace waitpid no se libera 
				(Estado Zombie)
			- Si el padre muere sin hacer waitpid, el proceso init "adopta" a sus hijos y se encarga de hacer waitpid
		ZEOS:
			- exit no recibe parametros
			- No implementamos sincronización con padre (no hay equivalente a waitpid)
			- Al hacer exit se liberan todos los recursos del hijo incluido el PCB

Planificacion de procesos:
	- Estados del proceso
	- El proceso pasa de Ready a Run en funcion de la politica de planificacion
	- Existe un planificador. Decide: el siguiente proceso a ejecutar y hasta cuando se ejecutará
	- Si el proceso que abandona la cpu no ha acabado la ejecucion hay que guardar su contexto de ejecucion

	Algorisme basic:
		updateSchedulingData()
		if (mustChangeProcess()) {
			queueProcess(current())
			next = selectNext()
			task_switch(next)
		}

Planificadores del sistema:
	Normalmente hay 3 planificadores en el sistema en funcion del tiempo para planificar el proceso:
		- Corto plazo: procesos pendientes del Procesador
			- Selecciona el siguiente proceso a ejecutar
			- Se ejecuta frecuentemente
				- Cuando acaba/empieza un proceso
				- Cada cierto tiempo (depende de la planificacion: Ej Round Robin)
				- Cuando un proceso inicia/finaliza la E/S
				- Ha de ser eficiente
			- Se usan diferentes politicas de planificacion:
				- FCFS (First Come First Served)
				- Prioridades
				- Round Robin
				- ...
		- Medio plazo: procesos swapped
			- Encargado de suspender y restaurar posteriormente procesos (swap out y swap in)
			- Se ejecuta cuando hay escasez de recursos: ej --> muchos procesos ejecutandose
			- Corrige errores del planificador a largo plazo
		- Largo plazo: en colas de batch
			- Controla el grado de multiprogramacion en el sistema
			- Se ejecuta cunado empieza/acaba un proceso
			- Opcional en sistemas de tiempo compartido <<REVISAR QUE ES ESTO>>

Politicas de planificacion y vocabulario relacionado:

- Rafaga de CPU --> Intervalo de tiempo consecutivo que un proceso esta ejecutandose en la CPU
- Rafaga de E/S --> Intervalo de tiempo consecutivo que un proceso esta realizando una E/S
- Diagramma de Gantt --> Diagrama horizontal que muestra para cada instante que valor toma un cierto parametro. En los apuntes
	se usa para respresentar el estado o informacion concreta de un proceso a lo largo del tiempo.
- Estados de un proceso:
	- Ready: Apropiacion diferida (quiere decir que en el momento que se cambia a ready se gana el derecho de entrar a la 
		CPU en algun momento más adelante)
	- Bloqued: Un proceso suele estar bloqued cuando espera un evento
	- Zombie: Un proceso que ha terminado pero que su proceso padre no ha leido que ha terminado mediante wait() o waitpid()
	- Running: Apropiacion immediata (basicamente quiere decir que en el momento que se cambia a running entra a la CPU 
		immediatamente)

Tipos de politicas de planificacion:
	- No Apropiativas: El SO no expulsa nunca al proceso de la CPU, el proceso abandona esta voluntariamente
		- FCFS (First Come First Served): Primer proceso en llegar a Ready es el primeo en ser planificado
	- Apropiativas: El SO puede expulsar procesos de la CPU y darsela a otro. Hay dos tipos:
		- Diferida:
			- Round Robin: El SO asigna un tiempo de CPU a cada proceso llamado quantum (puede ser constante o 
				calculado dinamicamente). El quantum no puede ser ni muy grande ni muy pequeño. Hay variantes
				donde aparte de esto, tambien se implementan prioridades.
		- Immediata: En algunas variantes de Round Robin con prioridades se usa apropiatividad immediata. Se tendrian 
			multiples colas Ready con diferentes prioridades y dentro de cada cola se aplicaria una politica 
			diferente.
	- Hibridas: es una mezcla de ambas:
		- Prioridades: estática, dinámica y estática+dinámica. El proceso mas prioritario es planificado para 
		ejecutarse. Entre procesos de igual prioridad: fifo (First In First Out). Puede tener potenciales problemas;
			- Starvation (un proceso nunca se ejecuta por no tener suficiente prioridad). La solucion seria aumentar
				la prioridad de un proceso conforme envejece (prioridad dinamica). 

En ZeOS: 
- Round Robin sin prioridad. 
- Quantum es una caracteristica de cada proceso.
- Estados: Ready, Run, Blocked
- Politica apropiativa diferida
- Idle se ejecuta si no hay nadie mas
- Lista de procesos libres: free

Estadísticas: Cuanto tiempo esta un proceso en cada estado/modo?
	Contador que indique ticks en:
		- User mode
		- System mode
		- Ready
		- Blocked


Threads o Flujos: Los threads de un proceso comparten todos los recursos asignados al proceso -> se usa clone para crear threads

Comparten:
	- PCB y stack del PROCESO (task_union)
	- Código (code segment)
	- Datos y heap (data segment and heap)
	- Archivos abiertos

No Comparten:

	- Estado de los registros: eip, eax, ebx...
	- Pila: cada thread tiene su pila de thread tanto para usuario como para kernel (supongo, REVISAR) 
	- Modo kernel: un thread puede entrar a modo kernel aunque haya threads del mismo proceso que no esten en modo kernel
	- TCB (thread control block): como el PCB pero de threads.
		- TID
		- 

LIBRERIA DE THREADS (Basada en POSIX Threads): Deberia implementar metodos para la gestion de estos a nivel de usuario. Ejemplos
	de metodos que deberia incluir:

	Creación:
		- pthread_create (pthread_t* tid, pthread_attr_t * attr, void *(* start_routine) (void *), void* arg)
			Parámetros:
				- tid
				- attr
				- start_routine
				- arg
			Que devuelve:
				- 0 si OK
				- Codigo de error
	Identificación: Devuelve el identificador del pthread
		- pthread_self ()
	
	Finalización: lo realiza el flujo que va a morir. Status es el valor que recibirá la funcion que espera la finalizacion 
		del thread. Es como el exit pero para threads:
		- pthread_exit (void* status)
	
	Sincronización fin de flujo: bloquea el thread que llama a esta funcion hasta que el thread pasado como parametro 
		finalice.
		- pthread_join (pthread_t tid, void **status)
			Parámetros:
				- thread: Identificador del flujo a esperar
				- status: Estado de finalización del flujo que estábamos esperando
			Que devuelve:
				- 0 si OK
				- Codigo de error

Sincronización entre procesos: 
Vocabulario:
	Region crítica: lineas de codigo que contienen data race

Problema --> Data race: si dos threads acceden a la misma variable puede que uno de los dos flujos lea un valor erroneo.
Solucion --> Exclusión mútua: se garantiza un acceso a la region crítica secuencial. Es el programador el que se encarga de 
	identificar las regiones críticas y tratarlas con exclusion mutua de la forma correspondiente.

	- Busy waiting (espera activa): es necesario que haya una instruccion de assembler dedicada a esto. Basicamente se 
		espera hasta que se pueda acceder a la variable compartida. El problema de esto es que se ocupa tiempo inutil 
		de cpu.

	- Semáforos: la idea simple es, una vez esta ocupada una region critica, en vez de esperar inutilmente a que este 
		disponible, el thread que no puede acceder se bloquea hasta que pueda acceder, y entonces de desbloquea. Un 
		semaforo es una estructura de datos del SO para proteger el acceso a recursos. Tiene asociado un contador y 
		una cola de procesos bloqueados. El contador indica la cantidad de procesos simultaneos de una seccion crítica.
		Ejemplo de implementacion de semaforos:
			– sem_init(sem,n): crea un semáforo
				sem->count = n;
				ini_queue (sem->queue);
			– sem_wait(sem): entrada en exclusión mutua (equivale al lock)
				sem->count --;
				If (sem->count < 0){
				 bloquear_flujo (sem->queue);
				}
			– sem_signal(sem): salida de exclusión mutua (equivale al unlock)
				sem->count ++;
				If (sem->count <= 0){
				 despertar_flujo (sem->queue);
				}


		En función del valor inicial del contador usaremos el semáforo para distintos fines
			– sem_init(sem,1): MUTEX (permitimos que 1 flujo acceda de forma simultanea a la sección crítica)
			– sem_init(sem,0): SINCRONIZACIÓN
			– sem_init(sem,N): RESTRICCIÓN DE RECURSOS, genérico
		Habitualmente usaremos:
			– Espera activa si los tiempos de espera se prevén cortos
			– Bloqueo si se prevén largos (bloquear un flujo es costoso (entrar a sistema))

		Problemas:
			- Deadlock (abrazo mortal): Se produce un abrazo mortal entre un conjunto de flujos, si cada flujo del 
			conjunto está bloqueado esperando un acontecimiento que solamente puede estar provocado por otro flujo 
			del conjunto.
				- Condiciones: minimo de 2 recursos no compatibles, un flujo consigue un recurso y espera por 
				otro, si un flujo conisigue un recurso solo el puede liberarlo y nadie se lo puede quitar, ha de
				haber una cadena de flujos donde cada uno necesita un recurso que tiene otro.
				- Soluciones: no dejar se cumplan las condiciones: tener recursos compartidos, poder quitar un
				recurso de un thread a otro, poder conseguir todos los recursos que se necesitan de forma
				atomica y/o ordenar las peticiones de recursos.

En linux:
int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);
	– Devuelve el PID del proceso creado
	– El proceso ejecuta la rutina fn(arg) – es diferente de fork()!!
	– Se le debe pasar una zona de memoria child_stack para ser usada como pila (lo único que debe tener cada task y que 
		no puede compartir)
	– flags:
		• CLONE_PARENT: el padre del proceso creado es el mismo que el del proceso creador
		• CLONE_FS: compartición de la información de file system
		• CLONE_FILES: compartición de la tabla de canales
		• CLONE_SIGHAND: compartición de la tabla de gestión de SIGNALS
		• ...
	– Internamente se usa esta llamada tanto para threads como para procesos
	– Se indica grado de compartición con el proceso que la usa
	– En Linux no se hace distinción threads/procesos a la hora de la planificación: todo son tasks que pueden compartir 
		(o no) recursos con otras tasks.
	- Task_struct contiene punteros a los datos en lugar de los datos en sí.

En ZeOS:
- No hay memoria dinamica: tabla con todos los posibles pcb's

- clone similar a linux: REVISAR
	- Los threads compartirán todo el espacio de direcciones del padre
	- Comparten directorio y tabla de páginas
	- Inicialización del contexto hardware
	- Cada thread empieza con los valores de registros de código y pila indicados como parámetro
	- Sólo necesitan heredar los valores de los registros de segmentos de datos de usuario

int clone(void (*fn)(void), char *stack);
	• Parámetros:
		– fn es la función a ejecutar por el nuevo thread
		– stack es la base de una zona de memoria para ser usada como pila
	• Devuelve:
		– El pid del nuevo thread creado
		– -1 en caso de error

En windows:
- Identificacion de un proceso en ejecución: hay un puntero al actual por cada procesador.
- Cambio de contexto: 
- Thread incluye
	– Thread Id
	– Conjunto de registros
	– Pila de usuario y pila de kernel
	– Area de almacenamiento privada
- Creacion de threads:
	HANDLE ThreadHandle = CreateThread (
		NULL, // Default Security attributes
		0, // Default Stack size
		rutina, // Routine to be executed
		&param, // Routine parameter
		0, // Default creation flags
		&ThreadId); // Returns Thread Identifier
	
	• WaitForSingleObject (ThreadHandle, INFINITE)
	• CloseHandle ( ThreadHandle )
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<GESTION DE ENTRADA/SALIDA>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Se entiende por E/S la transferencia de informacion hacia/desde un proceso, es necesaria su gestion para intercambiar 
informacion entre usuarios y entre procesos. Los dispositivos E/S son los que permiten hacer esta transferencia: teclado,
ficheros, red, pantalla...

Los dispositivos son muy diferentes entre sí. Un acceso a un dispositivo es complejo y muy dependiente del tipo de dispositivo 
concreto, requiere código de bajo nivel y los accesos simultáneos de varios usuarios podrían provocar interferencias.

El SO se encarga de gestionar el acceso a los dispositivos y garantizar uniformidad de operaciones, que no habra interferencias,
que se optimizará al máximo el rendimiento de los dispositivos y que se facilitará la incorporacion de nuevos dispositivos
minimizando los cambios en el codigo del SO.

Tres tipos de dispositivos:
	- Físico: No son visibles por el nivel de usuario. Device Driver: Codigo de bajo nivel dependiente del dispositivo que 
		accede directamente a este. Lo proporciona el fabricante del dispositivo e implementa la interfaz definida por 
		el SO. Se comunica directamente con el hardware (device controller) a traves de los registros del dispositivo.
	- Lógico: Abstraccion del SO para representar un dispositivo de E/S. Puede tener diferentes asociaciones:
		- 1 dispositivo hw (teclado)
		- 2 dispositivo hw (consola: teclado y pantalla)
		- ningun dispositivo hw (null)
		Puede añadir funcionalidades sobre un dispositivo hw: ficheros. <<REVISAR>>
		Visibles des de nivel de usuario. El usuario se refiere a un dispositivo logico para inicializar el uso de un
		nuevo dispositivo.
	- Virtual: Interfaz que usa el codigo de un usuario para acceder a un dispositivo. Todos los accesos se hacen a traves
		de dispositivos virtuales usando el mismo interfaz. El SO ofrece una llamada a sistema para asociar un 
		dispositivo virtual a un dispositivo lógico. Única llamada que depende del tipo de dispositivo que se quiere 
		usar.

Flujo de interaccion con dispositivos:
Usuario
	- open >> Dispositivo logico // vincula un dispositivo logico con uno virtual
	- read >> Dispositivo virtual >> Dispositivo logico
	- close >> Dispositivo virtual >> Dispositivo logico

Uso de dispositivos des de la vision de un Usuario:
	• int open (char *nombre, int modo, [int permisos])
	• int close (int canal)
	• int read(int canal, char *buff, int nbytes)
	• int write(int canal, char *buff, int nbytes)
	• dup, dup2, lseek
	• ioctl, fcntl

Estructuras de datos basicas en UNIX:
	- Tabla de Canales o dispositivos Virtuales (una por proceso)
	- Tabla de Ficheros Abiertos --> Características dinámicas
	- Tabla de I-nodes --> Características estáticas (Device Descriptor)
	- Directorio

Características dinámicas: modo de acceso, posición... Es decir, que pueden haber diferentes accesos a la vez, o puede cambiar
	de un acceso a otro, por eso son características dinámicas, porque cambian.

Características estáticas: descriptor de dispositivo (DD). Contiene información como el nombre, propietario, modo... Es 
	información que no cambia.

Tipos de accesos:
	- Compartido concurrente: Dos dispositivos virtuales diferentes acceden al dispositivo logico y accediendo a las mismas
		caracteristicas dinamicas y estaticas.
	- Compartido no concurrente: Dos dispositivos virtuales diferentes acceden al dispositivo logico accediendo a diferentes
		caracteristicas dinamicas, que sí acceden a las mismas características estáticas.

Flujo de datos:
	Tabla de canales (Dispositivo Virtual) >> Tabla de ficheros abiertos (Dispositivo logico) >>
	Tabla de I-nodes (Descriptor de Dispositivo y punteros a las funciones específicas de dispositivo) >>
	Device Driver (Dispositivo Físico)

El dipositivo lógico tiene asociado un driver. Cuando el sistema invoca una operacion del dispositivo logico, se invoca
una funcion especifica del driver, y este se comunica con el dipositivo físico. Esta comunicación puede ser de dos formas:
	- Por encuesta (polling): la CPU consulta constatemente al dispositivo si se ha realizado la operacion. 
	- Por interrupciones: El proceso programa la E/S y al finalizar recibe una interrupcion. El proceso puede bloquearse 
		y ceder la CPU hasta que se reciba la interrupcion.

Mecanismos de acceso al dispositivo:
	- E/S Síncrona: El proceso de usuario no continua su ejecucion hasta que finaliza la operacion de E/S
		Ejemplo de peticion de codigo sincrono a un gestor: 
			dep_read(fd,buff,size) {
				 parameters passing
				 signal(mng_sem)
				 wait(io_id)
				 take result and return
			}

	- E/S Asíncrona: El proceso de usuario se ejecuta concurrentemente mientras se realiza la E/S, y el SO le avisa cuando 
		este ha finalizado, de forma que puede consultar el estado de las operaciones pendientes.
		Ejemplo de peticion de codigo asincrono a un gestor: 
			dep_read(fd,buff,size) {
				 parameters passing
				 signal(mng_sem)
				 return(io_id)
			}
			wait_io(id_io) {
				 wait(id_io)
				 take result and return
			}

	- Implementación: 
		- Gestores: proceso de sistema encargado de atender y resolver peticiones de E/S. Ejemplo de Gestor:
			- Algoritmo general:
				for ( ; ; ) {
					esperar petición (wait)
					recoger parámetros --> elemento de la cola de IORB
					realizar E/S
					entregar resultados --> Se encola el io_fin a la cola de io_fin
					notificar finalización E/S (signal)
				}
			- Sincronización proceso gestor y usuario
				- Mediante semaforos (wait --> esperar_peticion/ signal --> enviar_peticion)
				- Fase 1: Solicitar una operacion E/S: signal para notificar al gestor, el gestor tiene que
					estar en wait esperando peticiones
				- Fase 2: Cuando solicita la E/S el proceso usuario se bloquea con wait sobre un semaforo
					propio y cuando el gestor finaliza envia un signal al proceso de usuario.
			- Paso de parametros
				- Mediante la estructura IORB (Input/Output Request block). Su contenido depende del 
					dispositivo. Cada gestor tiene una cola de IORB con las peticiones pendientes. Las
					rutinas de E/S rellenan y encolan las IORBs. Contenido:
					- @buffer: buffer de usuario donde estan los datos
					- Tipo de operacion: Lectura o escritura
					- id_io: Identificador de la operacion E/S que representa el IORB
					- @Descriptor de Dispositivo
					
			- Retorno de resultados
				- Mediante la estructura io_fin: contiene el id de la operacion E/S y su resultado. Tambien
					hay una cola de resultados por dispositivo y el gestor encola el io_fin y la rutina de
					E/S lo recoge.
				
	- Optimizaciones: 
		- Buffer: El dispositivo dispone de un buffer donde guarda los datos enviados/recibidos.
		- Doble buffering
		- Buffering circular
		- Spooling: la E/S se realiza sobre un dispositivo intermedio y el sistema la realizará posteriormente osbre el 
			dispositivo final. Ejemplo: una impresora si esta imprimiendo no puede imprimir otro documento a la vez,
			asi que al enviarse al dispositivo intermedio se pueden enviar mas peticiones de las que el dispositivo
			final puede asumir a la vez.
		- Algoritmos eficientes de acceso: Reordenar peticiones para mejorar la eficiencia en el acceso. Un ejemplo 
			seria usar politicas de planificacion de acceso a disco. Ejemplo: RAID --> distribucion de un fichero en
			diversos discos, permite accesos en paralelo y un aumento de la tolerancia a los fallos.

En linux:
Dispositivos logicos accesibles a traves del sistema de ficheros. Ficheros especiales normalmente situados en /dev 
(/dev/hda1 o /dev/audio0 ...). Se utilizan con las llamadas a sistema normales (open/read/write...). Se crean mediante mknod,
asigna dos numeros especiales al fichero, major y minor. Relaciona el dispositivo logico con el fisico. Asigna el tipo de E/S
por bloques o por carácteres.

Los device drivers son ficheros objeto que se pueden enlazar de forma dinámica con el kernel (modulos). De esta forma solamente
los drivers en uso estan en memoria (insmod, modprobe). El device driver se registra vinculando sus operaciones con su id.
Hay diferentes funciones de registro según el tipo de driver
	• int devfs_register_chrdev (unsigned int major, const char *name, struct file_operations *fops);
	• int devfs_register_blkdev (unsigned int major, const char *name, struct block_device_operations*bdops);
	• int register_netdevice(struct net_device *dev);
	• int register_filesystem(struct file_system_type *);
	• ...

El major establece la relacion entre el fichero y el driver de dispostivo a utilizar. Los numeros especificos dependen de cada
SO, en linux 2->pseudo terminales, 3->primer disco ide, 6->impresora...

El minor permite al driver distinguir entre diferentes dispositivos del mismo tipo. Ej: /dev/hda1, /dev/hda2 ....

En windows:
HANDLE CreateFile(name, access, sharemode, security, creation, attributes, NULL)
	Función utilizada por el sistema operativo
		– No es independiente del tipo de fichero
		– El usuario ha de saber qué tipo de fichero abrirá

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<COMUNICACIÓN ENTRE PROCESOS>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Metodos de Comunicacion entre procesos:
	- Memoria compartida
		- Entre flujos de un mismo proceso. Ej: cualquier variable global
		- Entre flujos de diferentes procesos. Ej: zona de memoria definida como compartida (shmget, shmat, shmdt...)
	- Paso de mensajes
		- Dispositivos para el intercambio de informacion
			- Sockets: procesos locales o remotos
			- Pipes: procesos locales. En linux se implementan mediante sockets.
				- Sin nombre: procesos relacionados por herencia
				- Con nombre
	- Signals: Notificación de eventos entre procesos del mismo usuario y en la misma maquina. 

Sockets: dispositivo logico de comunicacion bidireccional que se puede usar para comunicar procesos que estan en la misma 
maquina o en diferentes a traves de la red. Para su creacion es necesario definir:
	- Tipo de comunicacion:
		- Orientado a conexion (stream): Se establece un circuito virtual a traves del que se enviara la información,
			a la hora de enviar no hace falta establecer direccion destion porque ya está configurada.
		- No orientado a conexión (datagram): No establece circuito virtual. En cada envio se especifica el 
			destinatario. No se garantiza la recepcion del os paquetes ni su orden de llegada.
	- Espacio de nombres: para especificar direccion fuente y destino. Si los sockets son para comunicacion entre procesos
		dentro de una misma maquina: espacio de nombres de ficheros. Si son para comunicación a traves de la red, 
		espacio de nombres para direccionar dentro de internet:
			- Identificar host: direccion IP (32 bits si ipv4 o 128 si ipv6)
			- Identificar socket dentro del host: numero de puerto al que se asocia el socket (16 bits).
	- Un protocolo de comunicacion: Reglas para transmitir informacion:
		- TCP: orientado a conexión (stream)
		- UDP: no orientado a conexion (datagram)
		- UNIX Local Comunication: para transmision local

Nivel usuario:
	- Modelo cliente-Servidor:
		- Servidor: gestiona el acceso a un recurso
			- Secuencial o interactivo:
				- Recoge peticion y se la sirve
				- Resto de clientes tienen que esperar
			- Concurrente: varios threads o procesos sirviendo peticiones.
		- Cliente: peticiones de acceso al recurso

	- Modelo de comunicación:
		- Un socket por proceso: comunicación full-duplex.
		- Al crear un socket se le asocia un canal
		- Si se quiere que el socket sea accesible por otros procesos se tiene que publicar su direccion
			- Stream: solo hace falta que lo publique el servidor
			- Datagram: tienen que publicarlo tanto los clientes como el servidor
		- Accesos al socket:
			- Stream: read y write
			- Datagram: sendto y recvfrom
EJEMPLO STREAM
	Cliente: socket() >> connect() >> write() >> read()
	Servidor: socket() >> bind() >> listen() >> accept() >> read() >> write()

EJEMPLO DATAGRAM
	Cliente: socket() >> bind() >> sendto() >> recvfrom()
	Servidor: socket() >> bind() >> recvfrom() >> sendto() 

socket --> crea socket y asocia canal
bind --> asocia @ y publica
listen --> configura conexiones
accept --> espera solicitud de conexion
sendto --> indica destino

Endianess: puede ser que lleguen datos en un formato diferente al de nuestra maquina. Estas funciones adaptan la representación 
interna de la máquina a este formato y al revés:
	• htons (host to network short)
	• htonl (host to network long)
	• ntohs (network to host short)
	• ntohl (network to host long)

Implementación: MIRAR PRESENTACION PG 69

Pipes: 2 tipos
	- Sin nombre: solo la pueden utilizar procesos relacionados por herencia
	- Con nombre: tienen un nombre en el sistema de ficheros que las representa. Al crear el nombre se especifican 
		los permisos de acceso.
Tienen un comportamiento FIFO y estan pensadas para ser unidireccionales. Tipos de accesos:

	- Lectura: llamada a sistema read
		- Si hay suficientes datos en la pipe para servir la lectura se devuelven los datos que se han pedido
		- Si no hay suficientes datos (pero no esta vacía) se devuelven los datos que hay
		- Si se intenta leer una pipe vacia
			- Si no hay ningún canal de escritura asociado a la pipe: devuelve 0
			- Si hay algun canal de escritura asociado el proceso se bloquea hasta que alguien escribe algo o hasta
			que se cierran todos los canales de escritura
			- Importanet cerrar los canales de escritura en la pipe que no son necesarios
	- Escritura: llamada a sistema write
		- Si hay espacio en la pipe se escriben los datos y se acaba
		- Si no hay suficiente espacio se escriben los datos que quepan
		- Si se intenta escribir y la pipe esa llena, el proceso se bloquea hasta que se pueda escribir
		- Si no hay ningún canal de lectura asociado a la pipe, el proceso recibe SIGPIPE y el write acaba con error

Creación de dispositivo virtual:
	- Pipe sin nombre: Crea dos canales (los dos primeros libres): el primero asociado al extremo de lectura de la pipe y 
	es segundo asociado al extremo de escritura.
	
		#include <unistd.h>
		int pipe(int fd[2])

	- Pipe con nombre: Es necesario que tenga un nombre en el sistema de ficheros:
		#include <syst/stat>
		int mknod(char *path, mode_t mode, dev_t dev)
	Se usa para crear dispositivos logicos de todo tipo, mode codifica tipo de dispositivo y permisos de acceso, dev 
	contiene major y minor, aunque se ignora en el caso de una pipe. 
	Para crear una pipe: mknod("nombre", S_IFIFO|S_IRUSR|S_IWUSR);
	Para usarla: open("nombre", O_RDONLY); // se le pueden añadir flags para evitar bloqueos durante el uso.
	// Tambien se puede usar fcntl para modificar el comportamiento de dispositivos virtuales como evitar bloqueos.

- Implementación:
	Tienen asociado un I-nodo: con nombre se crean al cerar el nombre, y sin, se crean al crear la pipe. Inode:
		– Campo pipe_inode_info
			• Contiene buffers de memoria y las operaciones sobre ese buffer
		– Operaciones de acceso a la pipe
			• Acceden al buffer
			• Hay una estructura file_operations para cada modo de acceso y para cada tipo de pipe (con nombre y 
			sin nombre)
		– Semáforo para implementar los bloqueos

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<SISTEMA DE FICHEROS>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Fichero:
	- Para Usuario: conjunto de informacion relacionada que tiene un nombre
	- Para sistema: secuencia de bytes y dispositivo logico.

Sistema de ficheros: Conjunto de estructuras de datos y algoritmos para almacenar, localizar y recuperar información de un
dispositivo de almacenamiento persistente (ej. Disco). Tareas:
	- Gestionar espacio de almacenamiento
	- Encontrar/almacenar los datos de los ficheros
	- Organizar los ficheros en el sistema
	- Garantizar las protecciones de los ficheros
	- Gestion del espacio de nombres

Interfaz de usuario: Se accede mediante el interfaz E/S
	- Acceso a ficheros: open, read, write, close...
	- Gestion: link, unlink, chmod, chown...

Descripcion basica de HW:
- Discos mecánicos:
	- Unidad de trabajo Sector: 512 bytes, asignación y tranferencia
	- Tiempo de acceso (dominado por seektime)
		- Seek time: posicionamiento en pista y espera del sector
		- transferencia

- Almacenamiento SSD (Solid State Drive)
	- Unidad de trabajo Sector: 4096 bytes, asignacion y transferencia
	- Tiempo de acceso: transferencia (no hay seektime, acceso directo)	

Los sistemas de ficheros tradicionales no estan pensados para las características de SSD y su rendimiento degrada con el uso.

Organización del espacio de disco:
	- Particiones de disco:
		- Cada disco puede dividirse logicamente en particiones
		- Cada particion puede soportar un sistema de ficheros diferente
		- Maximo de 4 particiones por disco
	- Tipos de particiones
		- Primaria: soporte para un sistema de ficheros
		- Extendida: su objetivo es solventar la limitacion del numero maximo de particiones, tiene soporte para 
			dividir una particion primaria y crear nuevas particiones logicas.

Organización de una partición:
	- En una partición hay:
		- Datos: información guardada por el usuario
		- Metadatos: información necesaria para gestionar los datos y guardada por el sistema de ficheros

	- Esta organizada en bloques (1 bloque = n sectores), es la unidad de trabajo del sistema de ficheros 
	(acceso y transferencia). <<La correspondencia bloque sector puede ser fija, variable, grande, pequeña...
	Si los bloques son pequeños se aprovecha mejor el espacio pero hay que hacer muchos accesos, si los bloques son grandes
	aumenta el rendimiento porque hay menos accesos pero se desaprovecha mas espacio>>	

	- Gestion del espacio libre: localización de los bloques libres.
		Tener los bloques de tamaño fijo provoca que haya fragmentación, pese a ello, sigue siendo lo que mas se usa 
		por la complejidad elevada de la implementación de bloques de tamaño variable. Esta complejidad haria que sea 
		menos eficiente por el tiempo y recursos que se perderian en hacer los calculos y preparativos necesarios.

	- Gestion del espacio ocupado: asignación de bloques a ficheros y localizacion de los bloques de un fichero.

El sistema de ficheros utiliza una estructura donde se guarda la relacion entre el archivo y su espacio asignado. Normalmente
es accesible a través del directorio.

Mecansimos de asignación de bloques de memoria:
	- Asignación contigua: todos los bloques del archivo se asignan de manera consecutiva: CDROM, DVDs... Para cada archivo
		se necesita guardar bloque inicial y longitud del archivo. 

		- Ventajas: Acceso eficiente al dispositivo y localización del bloque i-ésimo sencilla

		- Desventajas: se produce fragmentación externa y necesita asignación previa (determinar tamaño a priori)

	- Asignación enlazada/encadenada --> cada bloque de datos reserva espacio para un puntero que indica cual es el 
		siguiente bloque del archivo. Para cada archivo se necesita guardar el bloque inicial.

		- Ventajas: asignación previa o dinámica y no hay fragmentación externa

		- Desventajas: para acceder al bloque i-ésimo hay que recorrer los anteriores (adecuado para accesos 
			secuenciales terrible para accesos directos). Poca fiabilidad, un fallo de un bloque seria crítico.

	- Asignacion enlazada/encadenada en tabla (FAT) --> Se enlazan tambien los bloques con punteros pero los punteros se 
		guardan en una tabla en lugar de ponerlos en los bloques de datos. Esta tabla se llama 
		FAT (File Allocation Table). Para cada archivo se necesita guardar nombre + bloque inicial + tamaño 
		(+info adicional). Para acceder al bloque i-ésimo basta con acceder a la tabla. El único inconveniente es que
		cuando los discos son grandes las tablas son grandes también.

	- Asignación indexada --> Existe un bloque índice para cada archivo y este índice contiene un vector de identificadores
		de bloques. Al final hay un puntero al siguiente bloque índice o a null. En cada entrada referencia a bloque de
		índices. 
		- Ventajas: Buen acceso secuencial y directo
		- Desventajas: Perdida de espacio para archivos pequeños (bloques de grandes indices) y muchos accesos en
			ficheros grandes (el numero de bloques de datos que un archivo puede usar esta limitado por el 
			tamaño del bloque indice<<REVISAR>>).

	- Asignación indexada multinivel --> En el bloque índice principal existen algunos apuntadores indirectos que apuntan 
		a nuevos bloques indices. Se crea una estructura jerárquica de bloques índice. i-nodo: contiene índices 
		directos e índices indirectos.
		- Ventajas: muy pocos accesos, incluso en ficheros grandes y poca perdida de espacio en ficheros pequeños
		- Desventajas: añadir o borrar datos que no estan al final del fichero.

Gestion del espacio libre: 
	- Bitmaps
	- Chained free portions
	- Indexing: free space as a file
	- Free block list

Gestion del espacio de nombres:
	- El espacio de nombres ofrece al usuario una vicion de todos los ficheros contenidos en el sistema de ficheros
	- Cada fichero debe tener un nombre simbólico
	- Define reglas específicas para crear nombres: EJ: en MSDOS nombres de 8 carácteres + 3 para extensión
	- Permite traducir los nombres de los ficheros a su ubicación en el sistema de ficheros

Gestion del espacio de nombres: Directorios
	- Archivo especial gestionado por el SO --> llamadas especificas de acceos y creación, no accesible directamente 
		mediante read/write
	
	- Da acceso a la información sobre los archivos
		- Atributos: Tipo de archivo, fechas de creacion, permisos ...
		- Ubicación en el dispositivo de almacenamiento
	
	- Si la información está dentro del directorio dificulta la creacion de links (diferentes nombres para un mismo archivo)
		- Estructura separada y el directorio solo referencia a ella
	
	- Operaciones de gestión: buscar, crear, borrar, enumerar, ectualizar entradas

Ejemplo: UNIX 

- MBR (Masater Boot Record) --> sector ubicado al inicio del disco (sector 0) para gestionar el disco y arrancar el SO.

Ext2: 
- Metadatos
	- Sector de arranque (boot) --> Info basica para arrancar el SO instalado en la partición
	- Superbloque 
		- Formato del SF (tamaño bloque, #inodes, #inodes libres, #bloques datos ,#bloques libres,…)
		- Gestión espacio libre/ocupado: inodes, cuál es el inode raíz, acceso a bloques libres, acceso a inodes libres 
	- Inodos --> asignación de bloques indexada multinivel
		- Bloque con información del archivo: Tamaño, tipo, protecciones...
		- Indices a bloques de datos (1 - 4kb) --> 
			- 10 índices directos, 
			- 1 índice indirecto, 
			- 1 índice indirecto doble
			- 1 índice indirecto triple
- Datos
	- Bloques de tamaño fijo
- Directorio
	- Enlaza un nombre de fichero con su inodo
	- Los atributos del fichero se encuentran en el inodo

Hay Ext3 o 4, son esquemas similares a la version 2 pero mas robustos ante posibles fallos a cambio de menor rendimiento. Las 
particiones se montan como /dev/sda1 o 2 .... 

Arquitectura del sistema de ficheros:
	- Capas: 
		proceso >> llamadas a sistema >> sistema de ficheros logico >> modulo organización archivos	
		>> sistema de ficheros físico >> drivers de disco, cinta o red
		
		- Sistema de ficheros logico: Proporciona la abstraccion fichero para realizar la E/S. Gestiona el espacio de
			nombres (directorio) y contiene la información necesaria para el siguiente nivel. 
		- Modulo de organización de archivos: correspondencia de archivos con bloques y gestion del 
			espacio libre/ocupado
		- Sistema de ficheros físico: Emite comandos al driver del dispositivo para leer/escribir bloques

	- Montaje de sistemas de ficheros: para acceder al sistema de ficheros de un dispositivo primero se ha de montar.
		- Montar: significa incluir el dispositivo (la partición) en el SF que maneja el SO para que sea accesible a 
			través de un directorio (punto de montaje). / es el dispositivo raíz que se monta en el directorio /
			del sistema de ficheros. Los demas dispositivos se pueden montar en cualquier directorio de sistema
			de ficheros.

- Linux: 
	- VFS (Virtual File System): proporciona un mecansimo orientado a objetos para acceder a todos estos sistemas
	de ficheros usando la misma interfaz de llamadas a sistema. Estructuras de datos en 2 niveles:
		- Independientes del sistema de ficheros: Contiene descripciones de los sistemas soportados y son 
			consultadas y modificadas por las llamadas a sistema (sys_open, sys_read...)
		- Dependientes del sistema de ficheros: estructuras internas para identificar ficheros, gestion del 
			espacio de disco ... Consultadas/modificadas por las rutinas específicas del VFS. 
			(sys_open_ext2(), sys_read_ext2...)

Los siguientes ejemplos son tipos de sistemas de ficheros logicos y modulos de organizacion de arhivos, abarcan ambos campos: 
llamadas a sistema >> VFS >> ext2, ext3, ntfs, nfs, xfs... >> sistema de ficheros fisico >> drivers
		
	- Estructuras Linux: Cada proceso tiene una tabla de canales --> struct files_struct. Cada canal apunta a un 
		ficheros abierto y contiene información sobre el dispositivo virtual. La tabla de ficheros abiertos
		es global a todo el sistema --> struct file, contiene posición actual, modo de acceso... cada fichero
		abierto apunta a su entrada de directorio. Para evitar accesos a disco inecesarios, los datos/metadatos
		mas usados se guardan en memoria: 
			- Superbloque
			- Cache de bloques (buffer cache): hay una cache para cada sistema de ficheros.
			- Cache de directorios (struct dentry): entradas de directorio usadas.
			- Tabla de inodos (struct inode): la estructura inode con sus operaciones.
Flujo de datos seria: 
tabla de canales (files_struct)>> tabla de ficheros abiertos (struct file) >> struct dentry >> tabla de inodos (struct inode)

Todas estas estructuras estan en C pero orientadas a objetos y tiene datos y codigo para acceder a ellas: file_operations,
dentry_operations y inode_operations.
EJ: 
Cas Read: sys_read (…)
	• vfs_read (file, buf, count, &pos)
		– Llama a file -> f_op -> read (file, buf, count, &pos)
Cas open: sys_open (filename, flags, mode)
	• filp_open (filename, flags, mode)
		– open_namei (filename, flags, mode, &nd) crea dentry (si no existia)
			» dentry_open (nd.dentry, nd.mnt, flags);
				- Llama a file -> f_op -> open (inode, file)


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<GESTION DE MEMORIA>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
- Memoria dinámica: mecanismo para gestionar de forma dinámica el espacio ocupado/libre de memoria. Permite reservar/liberar
  memoria en tiempo de ejecución. Esencialmente tiene dos operaciones: 
	· Reservar (malloc)
		- Validar nuevas zonas del espacio logico de direcciones: MMU y estructura de datos del SO que describe el 
			espacio
		- Asignar memoria física
	· Liberar (free)

	- Memoria dinamica para el sistema operativo:
		- Primera aproximación: sistema cutre (es cutre porque no se puede liberar memoria, solo reservar)
			- Definir zona de memoria estática
			- Gestionar el espacio libre/ocupado en esta zona
			- Solo se aceptan reservas: puntero a la última direccion valida no usada y la reserva incrementa ese 
				puntero
		- Buddy system: allocation en potencias de 2
			- Estructura para mantener los bloques libres de la memoria física
			- Solo reserva tamaños que son potencias de 2 (splitting)
			- Operaciones para dividir un bloque en 2 o juntar 2 bloques consecutivos (coalescing)
			Ejemplo de uso: inicialmente se tiene toda la memoria seleccionada y se va dividiendo en 2 hasta 
			conseguir el tamaño deseado, y para librerar memoria se van junta los bloques que se han separado
			previamente.

		- Slab allocator: Intenta resolver problemas buddy system. Es un mecanismo para reutilizar memoria de manera 
			eficiente en el kernel de SO. Se usa porque ciertas estructuras como PCB o semaforos son creadas y 
			destruidas continuamente y si solicitaramos y liberaramos memoria cada vez seria lento y fragmentaria la
			memoria. Funciona de forma que, reserva bloques de memoria grandes(slabs) en una fase inicial. Luego
			divide esos slabs en objetos más pequeños del mismo tipo y reutiliza los objetos (como semaforos o PCB)
			ya creados en vez de liberarlos completamente. Se usan caches para guardar objetos del kernel.
			- Slab: Region de memoria de 1 o más paginas consecutivas
			- Cache: Agrupación de 1 o más slabs. Cada cache contiene objetos del mismo tipo (mismo tamaño) y 
			información de si está en uso o no. 1 cache para PCBs, otra para semaforos, otra para ficheros...
			Estas cache son estructuras SOFTWARE no hardware.

	- Memoria dinamica para el usuario: el sistema se encarga de satisfacer las peticiones del usuario. Implica que el 
		espacio de direcciones varíe. En concreto la zona especial reservada para memoria dinámica: heap
		- sbrk:
			- void * sbrk (int incr) --> incrementa el heap en incr bytes, reservando esa cantidad en sistema. 
				Para decermentar simplemente se le pasa un parámetro negativo. Devuelve la dirección de 
				memoria a usar. Esto lo hace simplemente asignando paginas de memoria fisica para cubrir el
				espacio solicitado. Tambien evidentemente, actualiza las tablas de paginas.
 
		- malloc/free:
			- Doug Lea allocator (dlmalloc) --> Algoritmo muy popular para implementar malloc y free
				La memoria dinámica se organiza en chunks, que son bloques alineados a 8 bytes. Contienen:
					- Cabecera: informacion sobre su tamaño y un bit para indicar si esta libre o no
					- Zona de memoria usable: memoria disponible para el usuario
				- malloc: busca un chunk libre que sea lo suficientemente grande para satisfacer la solicitud
					- Si hay: se usa
					- Si hay más grande de lo necesario: se divide (splitting) en dos chunks, uno del 
						tamaño solicitado y otro que pasará a estar libre. 
					- Si no hay: se solicita más memoria al sistema mediante sbrk
				- free: marca el chunk como libre e intenta fusionarlo (coalescing) con los chunks libres 
					adyacentes para evitar fragmentación.
			Problema: fragmentación
				- Interna: espacio de un chunk que no es usado completamente
				- Externa: espacio entre chunks libres que no se pueden utilizar directamente porque estan 
					fragmentados
			Solucion: bins (cubetas)
				- El allocator matiene listas de chunks libres organizadas por tamaño
				- Facilita la búsqueda rápida de bloques libres

El flujo habitual del heap seria tener una cantidad de memoria dinamica inicial administrada mediante malloc/free, y si esta
se necesita aumentar o disminuir entonces llamar a sbrk.

- Memoria virtual: Tecnica que permite espacios de direcciones logicos mayores que los físicos.
	- Primera aproximación: intercambio de procesos (swapping)
		- Si no hay suficiente memoria libre se expulsa a otro proceso al area de swap(swap out)
		- Almacén secundario o de soporte (backing storage): espacio de intercambio; area de swap
		- Reanudar la ejecución de un proceso swapped out --> swap in
	- Evolución de la idea: expulsar solo partes de procesos y aprovechar granularidad de la paginación
		- Algoritmo: 
			- Detectar memoria no residente
			- Asignar memoria física mediante un algoritmo de reemplazo y guardar la memoria víctima en el area de
				swap
			- Recuperar memoria del backing storage
		- Para llevar a cabo el algoritmo anterior se necesita hw para la traduccion y deteccion de memoria no residente
			(memoria en el area de swap)
			- Mismo mecanismo que para carga bajo demanda
			- Excepción de page fault
		- Memoria virtual basanda en paginación
			- Espacio lógico de un proceso está distribuido entre memoria física (páginas residentes) y área de 
			swap (páginas no residentes)
				- Asignación de memoria física:
					- Estructura de datos para saber los frames libres
					- Algoritmo de selección
					- Actualizar espacio de direcciones con el frame seleccionado
					- Algoritmo de reemplazo:
						- Optimo (Se expulsa la que no se va a utilizar en un futuro inmediato): no se
							puede implementar, se basa en predecir.
						- FIFO (first in first out)			
						- LRU (Least Recently Used)

	- Estructuras de datos en linux:
		- Espacio de direcciones: Tabla de paginas, mm_struct: lista de regiones (vm_area_struct)
		- Frames libres: organizados en listas
		- Area de swap: partición de disco o fichero: vm_area_struct contiene la posicion de la región en disco
		- Algoritmo de reemplazo: LRU second chance
			- Bit de referencia en la tabla de paginas: cada vez que se accede a una pagina se marca como
				referenciada y cada vez que se ejecuta el algoritmo de reemplazo: 
				- Paginas referenciadas: se limpia el bit y se invalida el acceso
				- Paginas no referenciadas: se seleccionan como victimas

			- Rango de memoria libre: se comprueba al servir un fallo de página y cada cierto tiempo y se limpian
				n frames.
			- Parámetros configurables por le administrador

- Memoria compartida: entre threads ya se comparte si pertenecen al mismo proceso. Entre procesos no.
	- Nivel usuario: hay comandos específicos para compartir regiones de memoria: 
		- shmget: crear región
		- shmat: mapear en el espacio de direcciones
		- shmdt: liberar del espacio de direcciones
		- shmctl: eliminar región 
	También hay comandos para acceder a ficheros a traves de memoria:
		- mmap: mapeo
		- munmap: desmapeo 
	
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<ANEXO>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

A:
    __attribute__((__section__(".data.task")))--> Esto indica al compilador que debe colocar este array en una sección especial 
	de la memoria llamada .data.task. Esta sección está definida en el script del linker (.lds) y fue alineada a una 
	página de memoria (4096 bytes) lo cual es importante en sistemas operativos para asegurar que las estructuras críticas 
	(como las de planificación de tareas) estén alineadas en la memoria para mejorar la eficiencia de acceso y el uso de 
	la caché.
B: 
    sleep() --> normalemente se implementa a nivel de thread. Suele pasar lo siguiente:
	- Se marca como bloqueado en su TCB
	- El kernel lo coloca en una cola de espera asociada a temporizadores
	- El scheduler va mirando esta cola de procesos bloqueados a ver si ya toca desbloquear alguno
	- REVISAR
C: 
    ENDIANESS
	- Big Endian: byte de mayor peso en direccion baja
	- Little Endian: byte de mayor peso en direccion alta
